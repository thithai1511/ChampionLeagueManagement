/*
  Script đơn giản để liệt kê tất cả các bảng và cột
  Kết quả có thể export trực tiếp ra Excel/CSV
*/

-- Bảng 1: Tổng quan các bảng
SELECT 
    t.TABLE_NAME AS [Tên bảng],
    (SELECT COUNT(*) 
     FROM INFORMATION_SCHEMA.COLUMNS c 
     WHERE c.TABLE_NAME = t.TABLE_NAME) AS [Số cột],
    (SELECT COUNT(*) 
     FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
     INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc 
       ON kcu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME
     WHERE kcu.TABLE_NAME = t.TABLE_NAME 
       AND tc.CONSTRAINT_TYPE = 'PRIMARY KEY') AS [Số khóa chính],
    (SELECT COUNT(*) 
     FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
     INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
       ON rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
     WHERE kcu.TABLE_NAME = t.TABLE_NAME) AS [Số khóa ngoại]
FROM INFORMATION_SCHEMA.TABLES t
WHERE t.TABLE_TYPE = 'BASE TABLE'
  AND t.TABLE_NAME NOT LIKE 'sys%'
  AND t.TABLE_NAME NOT LIKE 'MS_%'
ORDER BY t.TABLE_NAME;

-- Bảng 2: Chi tiết tất cả các cột
SELECT 
    t.TABLE_NAME AS [Tên bảng],
    c.COLUMN_NAME AS [Tên cột],
    c.ORDINAL_POSITION AS [Vị trí],
    c.DATA_TYPE AS [Kiểu dữ liệu],
    CASE 
        WHEN c.CHARACTER_MAXIMUM_LENGTH IS NOT NULL AND c.CHARACTER_MAXIMUM_LENGTH <> -1 
        THEN CAST(c.CHARACTER_MAXIMUM_LENGTH AS VARCHAR) + ' ký tự'
        WHEN c.CHARACTER_MAXIMUM_LENGTH = -1 
        THEN 'MAX'
        WHEN c.NUMERIC_PRECISION IS NOT NULL 
        THEN CAST(c.NUMERIC_PRECISION AS VARCHAR) + ',' + CAST(c.NUMERIC_SCALE AS VARCHAR)
        ELSE ''
    END AS [Độ dài/Precision],
    CASE WHEN c.IS_NULLABLE = 'YES' THEN 'Có' ELSE 'Không' END AS [Cho phép NULL],
    ISNULL(c.COLUMN_DEFAULT, '') AS [Giá trị mặc định],
    CASE WHEN pk.COLUMN_NAME IS NOT NULL THEN 'Có' ELSE 'Không' END AS [Khóa chính],
    CASE WHEN fk.REFERENCED_TABLE IS NOT NULL 
        THEN fk.REFERENCED_TABLE + '.' + fk.REFERENCED_COLUMN 
        ELSE '' 
    END AS [Khóa ngoại tham chiếu]
FROM INFORMATION_SCHEMA.TABLES t
INNER JOIN INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME
LEFT JOIN (
    SELECT kcu.TABLE_NAME, kcu.COLUMN_NAME
    FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
    INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc 
        ON kcu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME
    WHERE tc.CONSTRAINT_TYPE = 'PRIMARY KEY'
) pk ON c.TABLE_NAME = pk.TABLE_NAME AND c.COLUMN_NAME = pk.COLUMN_NAME
LEFT JOIN (
    SELECT 
        kcu.TABLE_NAME,
        kcu.COLUMN_NAME,
        ccu.TABLE_NAME AS REFERENCED_TABLE,
        ccu.COLUMN_NAME AS REFERENCED_COLUMN
    FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
    INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
        ON rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
    INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu
        ON rc.UNIQUE_CONSTRAINT_NAME = ccu.CONSTRAINT_NAME
) fk ON c.TABLE_NAME = fk.TABLE_NAME AND c.COLUMN_NAME = fk.COLUMN_NAME
WHERE t.TABLE_TYPE = 'BASE TABLE'
  AND t.TABLE_NAME NOT LIKE 'sys%'
  AND t.TABLE_NAME NOT LIKE 'MS_%'
ORDER BY t.TABLE_NAME, c.ORDINAL_POSITION;

-- Bảng 3: Tổng hợp theo kiểu dữ liệu
SELECT 
    c.DATA_TYPE AS [Kiểu dữ liệu],
    COUNT(*) AS [Số lượng cột],
    COUNT(DISTINCT c.TABLE_NAME) AS [Số bảng sử dụng]
FROM INFORMATION_SCHEMA.COLUMNS c
INNER JOIN INFORMATION_SCHEMA.TABLES t ON c.TABLE_NAME = t.TABLE_NAME
WHERE t.TABLE_TYPE = 'BASE TABLE'
  AND t.TABLE_NAME NOT LIKE 'sys%'
  AND t.TABLE_NAME NOT LIKE 'MS_%'
GROUP BY c.DATA_TYPE
ORDER BY COUNT(*) DESC;

-- Bảng 4: Các khóa ngoại (Foreign Keys)
SELECT 
    kcu.TABLE_NAME AS [Bảng nguồn],
    kcu.COLUMN_NAME AS [Cột nguồn],
    ccu.TABLE_NAME AS [Bảng đích],
    ccu.COLUMN_NAME AS [Cột đích],
    rc.CONSTRAINT_NAME AS [Tên ràng buộc]
FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
    ON rc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
INNER JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu
    ON rc.UNIQUE_CONSTRAINT_NAME = ccu.CONSTRAINT_NAME
INNER JOIN INFORMATION_SCHEMA.TABLES t ON kcu.TABLE_NAME = t.TABLE_NAME
WHERE t.TABLE_TYPE = 'BASE TABLE'
  AND t.TABLE_NAME NOT LIKE 'sys%'
  AND t.TABLE_NAME NOT LIKE 'MS_%'
ORDER BY kcu.TABLE_NAME, kcu.COLUMN_NAME;




